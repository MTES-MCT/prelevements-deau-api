import {nanoid} from 'nanoid'
import mongo, {ObjectId} from '../util/mongo.js'
import {validateChanges, validateCreation} from '../validation/exploitation-validation.js'
import createHttpError from 'http-errors'

export async function getExploitationsFromPointId(idPoint) {
  return mongo.db.collection('exploitations').find(
    {
      point: idPoint,
      deletedAt: {$exists: false}
    }
  ).toArray()
}

export async function getExploitation(idExploitation) {
  return mongo.db.collection('exploitations').findOne(
    {
      _id: idExploitation,
      deletedAt: {$exists: false}
    }
  )
}

export async function createExploitation(payload, codeTerritoire) {
  const exploitation = validateCreation(payload)
  const pointId = mongo.parseObjectId(payload.point)

  const point = await mongo.db.collection('points_prelevement').findOne({_id: pointId})

  if (!point) {
    throw createHttpError(400, 'Ce point de prélèvement est introuvable.')
  }

  exploitation.point = pointId

  const preleveurId = mongo.parseObjectId(payload.preleveur)
  const preleveur = await mongo.db.collection('preleveurs').findOne({_id: preleveurId})

  if (!preleveur) {
    throw createHttpError(400, 'Ce préleveur est introuvable.')
  }

  exploitation.preleveur = preleveurId

  if (exploitation.documents.length > 0) {
    for (const document of exploitation.documents) {
      document.id_document = nanoid()
    }
  }

  if (exploitation.regles.length > 0) {
    for (const regle of exploitation.regles) {
      regle.id_regle = nanoid()
    }
  }

  if (exploitation.modalites.length > 0) {
    for (const modalite of exploitation.modalites) {
      modalite.id_modalite = nanoid()
    }
  }

  exploitation._id = new ObjectId()
  exploitation.id_exploitation = nanoid()
  exploitation.territoire = codeTerritoire
  exploitation.createdAt = new Date()
  exploitation.updatedAt = new Date()

  await mongo.db.collection('exploitations').insertOne(exploitation)

  return exploitation
}

export async function updateExploitation(idExploitation, payload) {
  const changes = validateChanges(payload)

  if (Object.keys(changes).length === 0) {
    throw createHttpError(400, 'Aucun champ valide trouvé.')
  }

  if (changes?.regles?.length > 0) {
    for (const regle of changes.regles) {
      regle.id_regle ||= nanoid()
    }
  }

  changes.updatedAt = new Date()

  const exploitation = await mongo.db.collection('exploitations').findOneAndUpdate(
    {_id: idExploitation, deletedAt: {$exists: false}},
    {$set: changes},
    {returnDocument: 'after'}
  )

  if (!exploitation) {
    throw createHttpError(404, 'Cette exploitation est introuvable.')
  }

  return exploitation
}

export async function deleteExploitation(exploitationId) {
  return mongo.db.collection('exploitations').findOneAndUpdate(
    {_id: exploitationId, deletedAt: {$exists: false}},
    {$set: {
      deletedAt: new Date(),
      updatedAt: new Date()
    }},
    {returnDocument: 'after'}
  )
}

export async function getMatchingExploitation(idPoint, {idPreleveur, dateValidite} = {}) {
  if (!idPoint) {
    throw new Error('idPoint is required')
  }

  const exploitationsPoint = await getExploitationsFromPointId(idPoint)

  const candidates = exploitationsPoint.filter(exploitation => {
    if (idPreleveur && exploitation.preleveur !== idPreleveur) {
      return false
    }

    if (dateValidite && (exploitation.date_debut > dateValidite || exploitation.date_fin < dateValidite)) {
      return false
    }

    return true
  })

  if (candidates.length === 0) {
    return null
  }

  if (candidates.length > 1) {
    throw new Error(`Multiple exploitations found for point ${idPoint} and preleveur ${idPreleveur}`)
  }

  return candidates[0]
}
