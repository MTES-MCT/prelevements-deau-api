import createHttpError from 'http-errors'
import {prisma} from '../../db/prisma.js'
import {randomUUID} from 'node:crypto'

export async function getExploitationsFromPointId(pointId) {
  return prisma.declarantPointPrelevement.findMany({
    where: {pointPrelevementId: pointId},
    orderBy: {createdAt: 'desc'},
    include: {
      pointPrelevement: true
    }
  })
}

export async function getExploitation(exploitationId) {
  return prisma.declarantPointPrelevement.findUnique({
    where: {id: exploitationId},
    include: {
      pointPrelevement: true,
      declarant: {
        include: {
          user: true
        }
      }
    }
  })
}

export async function pointHasActiveExploitation(pointId) {
  const count = await prisma.declarantPointPrelevement.count({
    where: {
      pointPrelevementId: pointId,
      status: 'EN_ACTIVITE',
      type: {in: ['PRELEVEUR_DECLARANT', 'PRELEVEUR_NON_DECLARANT']}
    }
  })

  return count > 0
}

export async function insertExploitation(exploitation) {
  try {
    return await prisma.declarantPointPrelevement.create({
      data: {
        id: randomUUID(),
        ...exploitation
      }
    })
  } catch (error) {
    // Conflit unique declarantUserId+pointPrelevementId
    if (error?.code === 'P2002') {
      throw createHttpError(409, 'Une exploitation existe déjà pour ce déclarant et ce point.')
    }

    throw error
  }
}

export async function updateExploitationById(exploitationId, changes) {
  if (!changes || typeof changes !== 'object') {
    throw createHttpError(400, 'Les modifications doivent être un objet.')
  }

  const existing = await prisma.declarantPointPrelevement.findUnique({
    where: {id: exploitationId},
    select: {id: true}
  })

  if (!existing) {
    throw createHttpError(404, 'Cette exploitation est introuvable.')
  }

  try {
    return await prisma.declarantPointPrelevement.update({
      where: {id: exploitationId},
      data: changes
    })
  } catch (error) {
    if (error?.code === 'P2002') {
      throw createHttpError(409, 'Conflit : doublon sur (déclarant, point).')
    }

    throw error
  }
}

export async function declarantHasExploitations(declarantUserId) {
  const count = await prisma.declarantPointPrelevement.count({
    where: {declarantUserId}
  })
  return count > 0
}

export async function getDeclarantExploitations(declarantUserId, include) {
  const safeInclude = include && typeof include === 'object' ? include : undefined

  return prisma.declarantPointPrelevement.findMany({
    where: {declarantUserId},
    ...(safeInclude ? {include: safeInclude} : {}),
    orderBy: {createdAt: 'desc'}
  })
}

export async function getPreleveurExploitationsViaPoints(preleveurId) {
  const pointsRows = await prisma.exploitation.findMany({
    where: {
      preleveurId,
      deletedAt: null,
      pointPrelevementId: {not: null}
    },
    select: {pointPrelevementId: true},
    distinct: ['pointPrelevementId']
  })

  const points = pointsRows.map(r => r.pointPrelevementId).filter(Boolean)
  if (points.length === 0) return []

  return prisma.exploitation.findMany({
    where: {
      deletedAt: null,
      pointPrelevementId: {in: points}
    }
  })
}

/* Requêtes liées aux documents */

export async function exploitationHasDocument(documentId) {
  return false

  // TODO:
  const count = await prisma.declarantPointPrelevement.count({
    where: {
      documentIds: {has: documentId}
    }
  })

  return count > 0
}

export async function deleteExploitation(exploitationId) {
  const existing = await prisma.declarantPointPrelevement.findUnique({
    where: {id: exploitationId},
    select: {id: true}
  })

  if (!existing) {
    throw createHttpError(404, 'Cette exploitation est introuvable.')
  }

  return prisma.declarantPointPrelevement.delete({
    where: {id: exploitationId}
  })
}

export async function bulkInsertExploitations(exploitations) {
  if (!Array.isArray(exploitations) || exploitations.length === 0) {
    return {insertedCount: 0}
  }

  const result = await prisma.declarantPointPrelevement.createMany({
    data: exploitations,
    skipDuplicates: true
  })

  return {insertedCount: result.count}
}
