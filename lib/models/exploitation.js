import {nanoid} from 'nanoid'
import mongo, {ObjectId} from '../util/mongo.js'
import {validateChanges, validateCreation} from '../validation/exploitation-validation.js'
import createHttpError from 'http-errors'

import {getPointPrelevement} from './point-prelevement.js'
import {getDocument} from './document.js'
import {getPreleveur} from './preleveur.js'
import {getNextSeqId} from '../util/sequences.js'

export async function getExploitationsFromPointId(pointId) {
  return mongo.db.collection('exploitations').find(
    {
      point: pointId,
      deletedAt: {$exists: false}
    }
  ).toArray()
}

export async function getExploitation(exploitationId) {
  return mongo.db.collection('exploitations').findOne(
    {
      _id: exploitationId,
      deletedAt: {$exists: false}
    }
  )
}

export async function decorateExploitation(exploitation) {
  if (!exploitation.documents || exploitation.documents.length === 0) {
    return exploitation
  }

  const documents = await Promise.all(
    exploitation.documents.map(docId => getDocument(docId))
  )

  return {
    ...exploitation,
    documents: documents.filter(Boolean)
  }
}

export async function getExploitationBySeqId(codeTerritoire, idExploitation) {
  return mongo.db.collection('exploitations').findOne(
    {id_exploitation: idExploitation, territoire: codeTerritoire}
  )
}

export async function pointHasActiveExploitation(pointId) {
  const count = await mongo.db.collection('exploitations').countDocuments({
    point: pointId,
    statut: 'En activité',
    deletedAt: {$exists: false}
  })

  return count > 0
}

export async function createExploitation(payload, codeTerritoire) {
  const exploitation = validateCreation(payload)
  const pointId = mongo.parseObjectId(payload.point)

  const point = await getPointPrelevement(pointId)

  if (!point) {
    throw createHttpError(400, 'Ce point de prélèvement est introuvable.')
  }

  exploitation.point = pointId

  const preleveurId = mongo.parseObjectId(payload.preleveur)
  const preleveur = await getPreleveur(preleveurId)

  if (!preleveur) {
    throw createHttpError(400, 'Ce préleveur est introuvable.')
  }

  exploitation.preleveur = preleveurId

  if (exploitation.documents.length > 0) {
    for (const document of exploitation.documents) {
      document.id_document = nanoid()
    }
  }

  if (exploitation.regles.length > 0) {
    for (const regle of exploitation.regles) {
      regle.id_regle = nanoid()
    }
  }

  if (exploitation.modalites.length > 0) {
    for (const modalite of exploitation.modalites) {
      modalite.id_modalite = nanoid()
    }
  }

  const nextId = await getNextSeqId(`territoire-${codeTerritoire}-exploitations`)

  exploitation._id = new ObjectId()
  exploitation.id_exploitation = nextId
  exploitation.territoire = codeTerritoire
  exploitation.createdAt = new Date()
  exploitation.updatedAt = new Date()

  await mongo.db.collection('exploitations').insertOne(exploitation)

  return exploitation
}

export async function updateExploitation(exploitationId, payload) {
  const changes = validateChanges(payload)

  if (Object.keys(changes).length === 0) {
    throw createHttpError(400, 'Aucun champ valide trouvé.')
  }

  if (changes?.regles?.length > 0) {
    for (const regle of changes.regles) {
      regle.id_regle ||= nanoid()
    }
  }

  changes.updatedAt = new Date()

  const exploitation = await mongo.db.collection('exploitations').findOneAndUpdate(
    {_id: exploitationId, deletedAt: {$exists: false}},
    {$set: changes},
    {returnDocument: 'after'}
  )

  if (!exploitation) {
    throw createHttpError(404, 'Cette exploitation est introuvable.')
  }

  return exploitation
}

export async function addDocumentsToExploitation(exploitationId, documentIds) {
  const updatedExploitation = await mongo.db.collection('exploitations').findOneAndUpdate(
    {_id: exploitationId, deletedAt: {$exists: false}},
    {$addToSet: {documents: {$each: documentIds}}},
    {returnDocument: 'after'}
  )

  if (!updatedExploitation) {
    throw createHttpError(404, 'Cette exploitation est introuvable.')
  }

  return updatedExploitation
}

export async function removeDocumentsFromExploitation(exploitationId, documentIds) {
  const updatedExploitation = await mongo.db.collection('exploitations').findOneAndUpdate(
    {_id: exploitationId, deletedAt: {$exists: false}},
    {$pull: {documents: {$in: documentIds}}},
    {returnDocument: 'after'}
  )

  if (!updatedExploitation) {
    throw createHttpError(404, 'Cette exploitation est introuvable.')
  }

  return updatedExploitation
}

export async function preleveurHasExploitations(preleveurId) {
  const count = await mongo.db.collection('exploitations').countDocuments({
    preleveur: preleveurId,
    deletedAt: {$exists: false}
  })

  return count > 0
}

export async function getPreleveurExploitations(preleveurId, projection) {
  return mongo.db.collection('exploitations').find(
    {preleveur: preleveurId, deletedAt: {$exists: false}},
    {projection}
  ).toArray()
}

export async function deleteExploitation(exploitationId) {
  return mongo.db.collection('exploitations').findOneAndUpdate(
    {_id: exploitationId, deletedAt: {$exists: false}},
    {$set: {
      deletedAt: new Date(),
      updatedAt: new Date()
    }},
    {returnDocument: 'after'}
  )
}

export async function bulkInsertExploitations(codeTerritoire, exploitations) {
  if (exploitations.length === 0) {
    return {insertedCount: 0}
  }

  const exploitationsToInsert = exploitations.map(exploitation => ({
    ...exploitation,
    territoire: codeTerritoire,
    createdAt: new Date(),
    updatedAt: new Date()
  }))

  const {insertedCount} = await mongo.db.collection('exploitations').insertMany(exploitationsToInsert)

  return {insertedCount}
}

export async function bulkDeleteExploitations(codeTerritoire) {
  await mongo.db.collection('exploitations').deleteMany({territoire: codeTerritoire})
}

export async function getMatchingExploitation(pointId, {preleveurId, dateValidite} = {}) {
  if (!pointId) {
    throw new Error('pointId is required')
  }

  const exploitationsPoint = await getExploitationsFromPointId(pointId)

  const candidates = exploitationsPoint.filter(exploitation => {
    if (preleveurId && !exploitation.preleveur.equals(preleveurId)) {
      return false
    }

    if (dateValidite && (exploitation.date_debut > dateValidite || exploitation.date_fin < dateValidite)) {
      return false
    }

    return true
  })

  if (candidates.length === 0) {
    return null
  }

  if (candidates.length > 1) {
    throw new Error(`Multiple exploitations found for point ${pointId} and preleveur ${preleveurId}`)
  }

  return candidates[0]
}
