import test from 'ava'
import {ObjectId} from 'mongodb'
import mongo from '../../util/mongo.js'
import {setupTestMongo, cleanupCollections} from '../../util/test-helpers/mongo.js'
import {
  insertExploitation,
  getExploitation,
  getExploitationBySeqId,
  updateExploitationById,
  deleteExploitation,
  getExploitationsFromPointId,
  pointHasActiveExploitation,
  preleveurHasExploitations,
  getPreleveurExploitations,
  exploitationHasDocument,
  bulkInsertExploitations,
  bulkDeleteExploitations
} from '../exploitation.js'

setupTestMongo(test)
cleanupCollections(test, ['exploitations', 'sequences'])

test.serial('insertExploitation / crée une exploitation avec seqId', async t => {
  const exploitation = {
    preleveur: new ObjectId(),
    point: new ObjectId(),
    usages: ['Agriculture'],
    statut: 'En activité',
    date_debut: '2024-01-01',
    date_fin: null,
    documents: []
  }

  const inserted = await insertExploitation(exploitation, 'TEST-001')

  t.truthy(inserted._id)
  t.is(inserted.territoire, 'TEST-001')
  t.is(inserted.id_exploitation, 1)
  t.deepEqual(inserted.usages, ['Agriculture'])
  t.truthy(inserted.createdAt)
})

test.serial('insertExploitation / incrémente le seqId', async t => {
  const exploitation1 = {
    preleveur: new ObjectId(),
    point: new ObjectId(),
    usages: ['Agriculture'],
    statut: 'En activité',
    date_debut: '2024-01-01'
  }

  const exploitation2 = {
    preleveur: new ObjectId(),
    point: new ObjectId(),
    usages: ['Eau potable'],
    statut: 'En activité',
    date_debut: '2024-01-01'
  }

  const inserted1 = await insertExploitation(exploitation1, 'TEST-001')
  const inserted2 = await insertExploitation(exploitation2, 'TEST-001')

  t.is(inserted1.id_exploitation, 1)
  t.is(inserted2.id_exploitation, 2)
})

test.serial('getExploitation / récupère une exploitation', async t => {
  const exploitation = {
    preleveur: new ObjectId(),
    point: new ObjectId(),
    usages: ['Agriculture'],
    statut: 'En activité',
    date_debut: '2024-01-01'
  }

  const inserted = await insertExploitation(exploitation, 'TEST-001')
  const found = await getExploitation(inserted._id)

  t.truthy(found)
  t.deepEqual(found._id, inserted._id)
  t.deepEqual(found.usages, ['Agriculture'])
})

test.serial('getExploitation / retourne null si non trouvé', async t => {
  const found = await getExploitation(new ObjectId())
  t.is(found, null)
})

test.serial('getExploitationBySeqId / récupère par territoire et seqId', async t => {
  const exploitation = {
    preleveur: new ObjectId(),
    point: new ObjectId(),
    usages: ['Agriculture'],
    statut: 'En activité',
    date_debut: '2024-01-01'
  }

  const inserted = await insertExploitation(exploitation, 'TEST-001')
  const found = await getExploitationBySeqId('TEST-001', inserted.id_exploitation)

  t.truthy(found)
  t.is(found.id_exploitation, inserted.id_exploitation)
})

test.serial('updateExploitationById / met à jour une exploitation', async t => {
  const exploitation = {
    preleveur: new ObjectId(),
    point: new ObjectId(),
    usages: ['Agriculture'],
    statut: 'En activité',
    date_debut: '2024-01-01'
  }

  const inserted = await insertExploitation(exploitation, 'TEST-001')
  const updated = await updateExploitationById(inserted._id, {
    statut: 'Terminée',
    date_fin: '2024-12-31'
  })

  t.is(updated.statut, 'Terminée')
  t.is(updated.date_fin, '2024-12-31')
  t.deepEqual(updated.usages, ['Agriculture']) // Inchangé
})

test.serial('updateExploitationById / lance une erreur si non trouvé', async t => {
  await t.throwsAsync(
    async () => updateExploitationById(new ObjectId(), {statut: 'Terminée'}),
    {message: /introuvable/}
  )
})

test.serial('deleteExploitation / supprime une exploitation (soft delete)', async t => {
  const exploitation = {
    preleveur: new ObjectId(),
    point: new ObjectId(),
    usages: ['Agriculture'],
    statut: 'En activité',
    date_debut: '2024-01-01'
  }

  const inserted = await insertExploitation(exploitation, 'TEST-001')
  const deleted = await deleteExploitation(inserted._id)

  t.truthy(deleted)
  t.truthy(deleted.deletedAt)

  const found = await getExploitation(inserted._id)
  t.is(found, null)
})

test.serial('getExploitationsFromPointId / récupère les exploitations d\'un point', async t => {
  const pointId = new ObjectId()
  const autrePointId = new ObjectId()

  await insertExploitation({
    preleveur: new ObjectId(),
    point: pointId,
    usages: ['Agriculture'],
    statut: 'En activité',
    date_debut: '2024-01-01'
  }, 'TEST-001')

  await insertExploitation({
    preleveur: new ObjectId(),
    point: pointId,
    usages: ['Eau potable'],
    statut: 'En activité',
    date_debut: '2024-01-01'
  }, 'TEST-001')

  await insertExploitation({
    preleveur: new ObjectId(),
    point: autrePointId,
    usages: ['Agriculture'],
    statut: 'En activité',
    date_debut: '2024-01-01'
  }, 'TEST-001')

  const exploitations = await getExploitationsFromPointId(pointId)

  t.is(exploitations.length, 2)
  t.true(exploitations.every(e => e.point.equals(pointId)))
})

test.serial('pointHasActiveExploitation / retourne true si point actif', async t => {
  const pointId = new ObjectId()

  await insertExploitation({
    preleveur: new ObjectId(),
    point: pointId,
    usages: ['Agriculture'],
    statut: 'En activité',
    date_debut: '2024-01-01'
  }, 'TEST-001')

  const hasActive = await pointHasActiveExploitation(pointId)
  t.true(hasActive)
})

test.serial('pointHasActiveExploitation / retourne false si aucun point actif', async t => {
  const pointId = new ObjectId()

  await insertExploitation({
    preleveur: new ObjectId(),
    point: pointId,
    usages: ['Agriculture'],
    statut: 'Terminée',
    date_debut: '2024-01-01'
  }, 'TEST-001')

  const hasActive = await pointHasActiveExploitation(pointId)
  t.false(hasActive)
})

test.serial('preleveurHasExploitations / retourne true si préleveur a des exploitations', async t => {
  const preleveurId = new ObjectId()

  await insertExploitation({
    preleveur: preleveurId,
    point: new ObjectId(),
    usages: ['Agriculture'],
    statut: 'En activité',
    date_debut: '2024-01-01'
  }, 'TEST-001')

  const hasExploitations = await preleveurHasExploitations(preleveurId)
  t.true(hasExploitations)
})

test.serial('getPreleveurExploitations / récupère les exploitations d\'un préleveur', async t => {
  const preleveurId = new ObjectId()
  const autrePreleveurId = new ObjectId()

  await insertExploitation({
    preleveur: preleveurId,
    point: new ObjectId(),
    usages: ['Agriculture'],
    statut: 'En activité',
    date_debut: '2024-01-01'
  }, 'TEST-001')

  await insertExploitation({
    preleveur: preleveurId,
    point: new ObjectId(),
    usages: ['Eau potable'],
    statut: 'En activité',
    date_debut: '2024-01-01'
  }, 'TEST-001')

  await insertExploitation({
    preleveur: autrePreleveurId,
    point: new ObjectId(),
    usages: ['Agriculture'],
    statut: 'En activité',
    date_debut: '2024-01-01'
  }, 'TEST-001')

  const exploitations = await getPreleveurExploitations(preleveurId)

  t.is(exploitations.length, 2)
  t.true(exploitations.every(e => e.preleveur.equals(preleveurId)))
})

test.serial('exploitationHasDocument / retourne true si exploitation a un document', async t => {
  const documentId = new ObjectId()

  await insertExploitation({
    preleveur: new ObjectId(),
    point: new ObjectId(),
    usages: ['Agriculture'],
    statut: 'En activité',
    date_debut: '2024-01-01',
    documents: [documentId]
  }, 'TEST-001')

  const hasDocument = await exploitationHasDocument(documentId)
  t.true(hasDocument)
})

test.serial('exploitationHasDocument / retourne false si aucune exploitation avec ce document', async t => {
  const documentId = new ObjectId()
  const hasDocument = await exploitationHasDocument(documentId)
  t.false(hasDocument)
})

test.serial('bulkInsertExploitations / insère plusieurs exploitations', async t => {
  const exploitations = [
    {
      _id: new ObjectId(),
      id_exploitation: 1,
      preleveur: new ObjectId(),
      point: new ObjectId(),
      usages: ['Agriculture'],
      statut: 'En activité',
      date_debut: '2024-01-01'
    },
    {
      _id: new ObjectId(),
      id_exploitation: 2,
      preleveur: new ObjectId(),
      point: new ObjectId(),
      usages: ['Eau potable'],
      statut: 'En activité',
      date_debut: '2024-01-01'
    }
  ]

  const result = await bulkInsertExploitations('TEST-001', exploitations)

  t.is(result.insertedCount, 2)

  const allExploitations = await mongo.db.collection('exploitations').find({territoire: 'TEST-001'}).toArray()
  t.is(allExploitations.length, 2)
})

test.serial('bulkDeleteExploitations / supprime toutes les exploitations d\'un territoire', async t => {
  await bulkInsertExploitations('TEST-001', [
    {
      _id: new ObjectId(),
      id_exploitation: 1,
      preleveur: new ObjectId(),
      point: new ObjectId(),
      usages: ['Agriculture'],
      statut: 'En activité',
      date_debut: '2024-01-01'
    }
  ])

  await bulkDeleteExploitations('TEST-001')

  const remaining = await mongo.db.collection('exploitations').find({territoire: 'TEST-001'}).toArray()
  t.is(remaining.length, 0)
})
