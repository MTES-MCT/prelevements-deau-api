import test from 'ava'
import {ObjectId} from 'mongodb'
import {setupTestMongo, cleanupCollections} from '../../util/test-helpers/mongo.js'
import * as ExploitationService from '../exploitation.js'
import * as PreleveurModel from '../../models/declarant.js'
import * as PointPrelevementModel from '../../models/point-prelevement.js'
import * as ExploitationModel from '../../models/exploitation.js'

setupTestMongo(test)
cleanupCollections(test, ['exploitations', 'preleveurs', 'points_prelevement', 'sequences'])

test.serial('createExploitation / crée une exploitation valide', async t => {
  // Créer un préleveur
  const preleveur = await PreleveurModel.insertDeclarant('TEST-001', {
    nom: 'Préleveur Test',
    statut: 'En activité'
  })

  // Créer un point
  const point = await PointPrelevementModel.insertPointPrelevement({
    nom: 'Point Test',
    statut: 'Actif',
    coordonnees: {type: 'Point', coordinates: [2.3522, 48.8566]}
  }, 'TEST-001')

  const payload = {
    preleveur: preleveur._id.toString(),
    point: point._id.toString(),
    usages: ['Agriculture'],
    statut: 'En activité',
    date_debut: '2024-01-01',
    date_fin: null
  }

  const exploitation = await ExploitationService.createExploitation(payload, 'TEST-001')

  t.truthy(exploitation._id)
  t.truthy(exploitation.id_exploitation)
  t.deepEqual(exploitation.preleveur, preleveur._id)
  t.deepEqual(exploitation.point, point._id)
  t.deepEqual(exploitation.usages, ['Agriculture'])
})

test.serial('createExploitation / lance une erreur si point introuvable', async t => {
  const preleveur = await PreleveurModel.insertDeclarant('TEST-001', {
    nom: 'Préleveur Test',
    statut: 'En activité'
  })

  const payload = {
    preleveur: preleveur._id.toString(),
    point: new ObjectId().toString(),
    usages: ['Agriculture'],
    statut: 'En activité',
    date_debut: '2024-01-01'
  }

  await t.throwsAsync(
    async () => ExploitationService.createExploitation(payload, 'TEST-001'),
    {message: /point de prélèvement est introuvable/}
  )
})

test.serial('createExploitation / lance une erreur si préleveur introuvable', async t => {
  const point = await PointPrelevementModel.insertPointPrelevement({
    nom: 'Point Test',
    statut: 'Actif',
    coordonnees: {type: 'Point', coordinates: [2.3522, 48.8566]}
  }, 'TEST-001')

  const payload = {
    preleveur: new ObjectId().toString(),
    point: point._id.toString(),
    usages: ['Agriculture'],
    statut: 'En activité',
    date_debut: '2024-01-01'
  }

  await t.throwsAsync(
    async () => ExploitationService.createExploitation(payload, 'TEST-001'),
    {message: /préleveur est introuvable/}
  )
})

test.serial('updateExploitation / met à jour une exploitation', async t => {
  const exploitation = await ExploitationModel.insertExploitation({
    preleveur: new ObjectId(),
    point: new ObjectId(),
    usages: ['Agriculture'],
    statut: 'En activité',
    date_debut: '2024-01-01'
  }, 'TEST-001')

  const updated = await ExploitationService.updateExploitation(exploitation._id, {
    statut: 'Terminée',
    date_fin: '2024-12-31'
  })

  t.is(updated.statut, 'Terminée')
  t.is(updated.date_fin, '2024-12-31')
  t.deepEqual(updated.usages, ['Agriculture']) // Inchangé
})

test.serial('updateExploitation / lance une erreur si aucun champ valide', async t => {
  const exploitation = await ExploitationModel.insertExploitation({
    preleveur: new ObjectId(),
    point: new ObjectId(),
    usages: ['Agriculture'],
    statut: 'En activité',
    date_debut: '2024-01-01'
  }, 'TEST-001')

  await t.throwsAsync(
    async () => ExploitationService.updateExploitation(exploitation._id, {}),
    {message: /Aucun champ valide/}
  )
})

test.serial('getMatchingExploitation / trouve une exploitation par point', async t => {
  const pointId = new ObjectId()
  const preleveurId = new ObjectId()

  await ExploitationModel.insertExploitation({
    preleveur: preleveurId,
    point: pointId,
    usages: ['Agriculture'],
    statut: 'En activité',
    date_debut: '2024-01-01',
    date_fin: '2024-12-31'
  }, 'TEST-001')

  const found = await ExploitationService.getMatchingExploitation(pointId)

  t.truthy(found)
  t.deepEqual(found.point, pointId)
})

test.serial('getMatchingExploitation / filtre par préleveur', async t => {
  const pointId = new ObjectId()
  const preleveurId1 = new ObjectId()
  const preleveurId2 = new ObjectId()

  await ExploitationModel.insertExploitation({
    preleveur: preleveurId1,
    point: pointId,
    usages: ['Agriculture'],
    statut: 'En activité',
    date_debut: '2024-01-01',
    date_fin: '2024-12-31'
  }, 'TEST-001')

  await ExploitationModel.insertExploitation({
    preleveur: preleveurId2,
    point: pointId,
    usages: ['Eau potable'],
    statut: 'En activité',
    date_debut: '2024-01-01',
    date_fin: '2024-12-31'
  }, 'TEST-001')

  const found = await ExploitationService.getMatchingExploitation(pointId, {
    preleveurId: preleveurId2
  })

  t.truthy(found)
  t.deepEqual(found.preleveur, preleveurId2)
  t.deepEqual(found.usages, ['Eau potable'])
})

test.serial('getMatchingExploitation / retourne null si aucune correspondance', async t => {
  const pointId = new ObjectId()
  const found = await ExploitationService.getMatchingExploitation(pointId)
  t.is(found, null)
})

test.serial('getMatchingExploitation / lance une erreur si multiples correspondances', async t => {
  const pointId = new ObjectId()
  const preleveurId = new ObjectId()

  await ExploitationModel.insertExploitation({
    preleveur: preleveurId,
    point: pointId,
    usages: ['Agriculture'],
    statut: 'En activité',
    date_debut: '2024-01-01',
    date_fin: '2024-06-30'
  }, 'TEST-001')

  await ExploitationModel.insertExploitation({
    preleveur: preleveurId,
    point: pointId,
    usages: ['Agriculture'],
    statut: 'En activité',
    date_debut: '2024-07-01',
    date_fin: '2024-12-31'
  }, 'TEST-001')

  await t.throwsAsync(
    async () => ExploitationService.getMatchingExploitation(pointId, {preleveurId}),
    {message: /Multiple exploitations found/}
  )
})

test.serial('getMatchingExploitation / filtre par date de validité', async t => {
  const pointId = new ObjectId()
  const preleveurId = new ObjectId()

  await ExploitationModel.insertExploitation({
    preleveur: preleveurId,
    point: pointId,
    usages: ['Agriculture'],
    statut: 'En activité',
    date_debut: '2024-01-01',
    date_fin: '2024-06-30'
  }, 'TEST-001')

  await ExploitationModel.insertExploitation({
    preleveur: preleveurId,
    point: pointId,
    usages: ['Eau potable'],
    statut: 'En activité',
    date_debut: '2024-07-01',
    date_fin: '2024-12-31'
  }, 'TEST-001')

  const found = await ExploitationService.getMatchingExploitation(pointId, {
    preleveurId,
    dateValidite: '2024-08-15'
  })

  t.truthy(found)
  t.deepEqual(found.usages, ['Eau potable'])
  t.is(found.date_debut, '2024-07-01')
})
