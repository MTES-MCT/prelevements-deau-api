import createHttpError from 'http-errors'
import {parseObjectId} from '../util/mongo.js'

// Import des models
import * as ExploitationModel from '../models/exploitation.js'
import {getPointPrelevement} from '../models/point-prelevement.js'
import {getDeclarant} from '../models/declarant.js'
import {getDocument} from '../models/document.js'

// Import des services
import {decorateDocument} from './document.js'

// Import de la validation
import {validateCreation, validateChanges} from '../validation/exploitation-validation.js'

/**
 * Service layer pour les exploitations
 * Contient la logique métier et l'orchestration entre models
 */

/* Création avec validation croisée */

export async function createExploitation(payload) {
  const exploitation = validateCreation(payload)
  const pointId = parseObjectId(payload.point)

  // Validation métier : le point doit exister
  const point = await getPointPrelevement(pointId)
  if (!point) {
    throw createHttpError(400, 'Ce point de prélèvement est introuvable.')
  }

  exploitation.point = pointId

  // Validation métier : le préleveur doit exister
  const preleveurId = parseObjectId(payload.preleveur)
  const preleveur = await getDeclarant(preleveurId)
  if (!preleveur) {
    throw createHttpError(400, 'Ce préleveur est introuvable.')
  }

  exploitation.preleveur = preleveurId

  return ExploitationModel.insertExploitation(exploitation)
}

/* Mise à jour */

export async function updateExploitation(exploitationId, payload) {
  const changes = validateChanges(payload)

  if (Object.keys(changes).length === 0) {
    throw createHttpError(400, 'Aucun champ valide trouvé.')
  }

  return ExploitationModel.updateExploitationById(exploitationId, changes)
}

/* Suppression */

export async function deleteExploitation(exploitationId) {
  const exploitation = await ExploitationModel.getExploitation(exploitationId)

  if (!exploitation) {
    throw createHttpError(404, 'Cette exploitation est introuvable.')
  }

  // Note: Vérification des séries de données à ajouter ultérieurement si nécessaire
  // Pour l'instant, on autorise la suppression (soft delete)

  return ExploitationModel.deleteExploitation(exploitationId)
}

/* Décoration avec informations enrichies */

export async function decorateExploitation(exploitation) {
  // Enrichir l'exploitation avec les documents complets et décorés
  const documentsPromises = (exploitation.documents || []).map(async docId => {
    const doc = await getDocument(docId)
    return doc ? decorateDocument(doc) : null
  })
  const documentsResults = await Promise.all(documentsPromises)
  const documents = documentsResults.filter(Boolean)

  return {
    ...exploitation,
    documents
  }
}

/* Logique de matching complexe */

export async function getMatchingExploitation(pointId, {preleveurId, dateValidite} = {}) {
  if (!pointId) {
    throw new Error('pointId is required')
  }

  const exploitationsPoint = await ExploitationModel.getExploitationsFromPointId(pointId)

  const candidates = exploitationsPoint.filter(exploitation => {
    if (preleveurId && !exploitation.preleveur.equals(preleveurId)) {
      return false
    }

    if (dateValidite && (exploitation.date_debut > dateValidite || exploitation.date_fin < dateValidite)) {
      return false
    }

    return true
  })

  if (candidates.length === 0) {
    return null
  }

  if (candidates.length > 1) {
    throw new Error(`Multiple exploitations found for point ${pointId} and preleveur ${preleveurId}`)
  }

  return candidates[0]
}
