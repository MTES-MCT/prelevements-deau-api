import {nanoid} from 'nanoid'
import createHttpError from 'http-errors'
import mongo from '../util/mongo.js'

// Import des models
import * as ExploitationModel from '../models/exploitation.js'
import {getPointPrelevement} from '../models/point-prelevement.js'
import {getPreleveur} from '../models/preleveur.js'

// Import de la validation
import {validateCreation, validateChanges} from '../validation/exploitation-validation.js'

/**
 * Service layer pour les exploitations
 * Contient la logique métier et l'orchestration entre models
 */

/* Création avec validation croisée */

export async function createExploitation(payload, codeTerritoire) {
  const exploitation = validateCreation(payload)
  const pointId = mongo.parseObjectId(payload.point)

  // Validation métier : le point doit exister
  const point = await getPointPrelevement(pointId)
  if (!point) {
    throw createHttpError(400, 'Ce point de prélèvement est introuvable.')
  }

  exploitation.point = pointId

  // Validation métier : le préleveur doit exister
  const preleveurId = mongo.parseObjectId(payload.preleveur)
  const preleveur = await getPreleveur(preleveurId)
  if (!preleveur) {
    throw createHttpError(400, 'Ce préleveur est introuvable.')
  }

  exploitation.preleveur = preleveurId

  // Génération des IDs pour les sous-documents
  if (exploitation.documents?.length > 0) {
    for (const document of exploitation.documents) {
      document.id_document = nanoid()
    }
  }

  if (exploitation.regles?.length > 0) {
    for (const regle of exploitation.regles) {
      regle.id_regle = nanoid()
    }
  }

  return ExploitationModel.insertExploitation(exploitation, codeTerritoire)
}

/* Mise à jour avec génération d'IDs */

export async function updateExploitation(exploitationId, payload) {
  const changes = validateChanges(payload)

  if (Object.keys(changes).length === 0) {
    throw createHttpError(400, 'Aucun champ valide trouvé.')
  }

  // Génération des IDs pour les nouvelles règles
  if (changes?.regles?.length > 0) {
    for (const regle of changes.regles) {
      regle.id_regle ||= nanoid()
    }
  }

  return ExploitationModel.updateExploitationById(exploitationId, changes)
}

/* Logique de matching complexe */

export async function getMatchingExploitation(pointId, {preleveurId, dateValidite} = {}) {
  if (!pointId) {
    throw new Error('pointId is required')
  }

  const exploitationsPoint = await ExploitationModel.getExploitationsFromPointId(pointId)

  const candidates = exploitationsPoint.filter(exploitation => {
    if (preleveurId && !exploitation.preleveur.equals(preleveurId)) {
      return false
    }

    if (dateValidite && (exploitation.date_debut > dateValidite || exploitation.date_fin < dateValidite)) {
      return false
    }

    return true
  })

  if (candidates.length === 0) {
    return null
  }

  if (candidates.length > 1) {
    throw new Error(`Multiple exploitations found for point ${pointId} and preleveur ${preleveurId}`)
  }

  return candidates[0]
}
