import test from 'ava'
import {validateCreation, validateChanges} from '../exploitation-validation.js'
import {ValidationError} from '../../util/payload.js'

function exploitationValideComplete() {
  return {
    date_debut: '2024-01-01',
    date_fin: null,
    statut: 'En activité',
    raison_abandon: null,
    remarque: null,
    point: '1234567890abcdef12345678',
    preleveur: 'abcdef1234567890abcdef12',
    usages: ['Eau potable'],
    documents: []
  }
}

// ---------------- Exploitation creation schema tests ----------------

test('exploitationSchemaCreation / valide complet', t => {
  const input = exploitationValideComplete()
  const value = validateCreation(input)
  t.deepEqual(value, input)
})

test('exploitationSchemaCreation / statut manquant', t => {
  const input = exploitationValideComplete()
  delete input.statut
  const error = t.throws(() => validateCreation(input), {instanceOf: ValidationError})
  t.true(error.details.some(d => d.message === 'Le statut est obligatoire.'))
})

test('exploitationSchemaCreation / date_debut manquante', t => {
  const input = exploitationValideComplete()
  delete input.date_debut
  const error = t.throws(() => validateCreation(input), {instanceOf: ValidationError})
  t.true(error.details.some(d => d.message === 'Une date de début est obligatoire.'))
})

test('exploitationSchemaCreation / usages vide', t => {
  const input = exploitationValideComplete()
  input.usages = []
  const error = t.throws(() => validateCreation(input), {instanceOf: ValidationError})
  t.true(error.details.some(d => d.message === 'Au moins un usage est obligatoire.'))
})

test('exploitationSchemaCreation / point id invalide', t => {
  const input = exploitationValideComplete()
  input.point = '123' // Trop court
  const error = t.throws(() => validateCreation(input), {instanceOf: ValidationError})
  t.true(error.details.length > 0)
})

test('exploitationSchemaCreation / documents doit être un tableau', t => {
  const input = exploitationValideComplete()
  input.documents = ['1234567890abcdef12345678', 'abcdef1234567890abcdef12'] // ObjectIds valides de 24 chars
  const value = validateCreation(input)
  t.deepEqual(value.documents, ['1234567890abcdef12345678', 'abcdef1234567890abcdef12'])
})

test('exploitationSchemaCreation / documents ObjectId invalide', t => {
  const input = exploitationValideComplete()
  input.documents = ['invalid'] // Pas un ObjectId valide
  const error = t.throws(() => validateCreation(input), {instanceOf: ValidationError})
  t.true(error.details.length > 0)
})

test('exploitationSchemaCreation / raison_abandon trop courte', t => {
  const input = exploitationValideComplete()
  input.raison_abandon = 'ab'
  const error = t.throws(() => validateCreation(input), {instanceOf: ValidationError})
  t.true(error.details.some(d => d.message.includes('raison_abandon') && d.message.includes('au moins')))
})

test('exploitationSchemaCreation / raison_abandon trop longue', t => {
  const input = exploitationValideComplete()
  input.raison_abandon = 'a'.repeat(600)
  const error = t.throws(() => validateCreation(input), {instanceOf: ValidationError})
  t.true(error.details.some(d => d.message.includes('raison_abandon') && d.message.includes('plus de')))
})

test('exploitationSchemaCreation / remarque trop courte', t => {
  const input = exploitationValideComplete()
  input.remarque = 'ab'
  const error = t.throws(() => validateCreation(input), {instanceOf: ValidationError})
  t.true(error.details.some(d => d.message.includes('remarque') && d.message.includes('au moins')))
})

// ---------------- Exploitation edition schema tests ----------------

test('exploitationSchemaEdition / valide partiel', t => {
  const changes = {
    remarque: 'Mise à jour',
    usages: ['Agriculture']
  }
  const value = validateChanges(changes)
  t.deepEqual(value, changes)
})

test('exploitationSchemaEdition / usage invalide', t => {
  const changes = {usages: ['Bidon']}
  const error = t.throws(() => validateChanges(changes), {instanceOf: ValidationError})
  t.true(error.details.some(d => d.message === 'Cet usage est invalide.'))
})

test('exploitationSchemaEdition / statut invalide', t => {
  const changes = {statut: 'Bidon'}
  const error = t.throws(() => validateChanges(changes), {instanceOf: ValidationError})
  t.true(error.details.some(d => d.message === 'Ce statut est invalide.'))
})

test('exploitationSchemaEdition / date format invalide', t => {
  const changes = {date_debut: '20240101'}
  const error = t.throws(() => validateChanges(changes), {instanceOf: ValidationError})
  t.true(error.details.some(d => d.message === 'La date est invalide.'))
})

test('exploitationSchemaEdition / point hex invalide', t => {
  const changes = {point: 'zzz'}
  const error = t.throws(() => validateChanges(changes), {instanceOf: ValidationError})
  t.true(error.details.length > 0)
})

test('exploitationSchemaEdition / preleveur hex invalide', t => {
  const changes = {preleveur: '123'}
  const error = t.throws(() => validateChanges(changes), {instanceOf: ValidationError})
  t.true(error.details.length > 0)
})

test('exploitationSchemaEdition / documents peut être mis à jour', t => {
  const changes = {documents: ['1234567890abcdef12345678']}
  const value = validateChanges(changes)
  t.deepEqual(value.documents, ['1234567890abcdef12345678'])
})

test('exploitationSchemaEdition / multiple erreurs', t => {
  const changes = {statut: 'Bidon', usages: ['Bidon'], date_debut: '20240101'}
  const error = t.throws(() => validateChanges(changes), {instanceOf: ValidationError})
  const msgs = new Set(error.details.map(d => d.message))
  t.true(msgs.has('Ce statut est invalide.'))
  t.true(msgs.has('Cet usage est invalide.'))
  t.true(msgs.has('La date est invalide.'))
})
