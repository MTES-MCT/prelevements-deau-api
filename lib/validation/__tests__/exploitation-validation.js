import test from 'ava'
import {validateCreation, validateChanges, documentSchema, regleSchema} from '../exploitation-validation.js'
import {natures, parametres, unites, contraintes, usages as usagesNomenclature, statutsExploitation} from '../../nomenclature.js'
import {validatePayload, ValidationError} from '../../util/payload.js'

// ---------------- Document schema tests ----------------

function validateDocument(doc) {
  return validatePayload(doc, documentSchema)
}

test('documentSchema / valide', t => {
  const input = {
    nom_fichier: 'autorisation.pdf',
    reference: 'REF-123',
    nature: Object.values(natures)[0],
    date_signature: '2024-01-01',
    date_fin_validite: null,
    date_ajout: '2024-02-01',
    remarque: 'RAS'
  }
  const value = validateDocument(input)
  t.deepEqual(value, input)
})

test('documentSchema / invalide nature', t => {
  const input = {
    nom_fichier: 'doc.pdf',
    reference: null,
    nature: 'Bidon',
    date_signature: '2024-01-01',
    date_fin_validite: null,
    date_ajout: '2024-02-01',
    remarque: null
  }
  const error = t.throws(() => validateDocument(input), {instanceOf: ValidationError})
  t.true(error.details.some(d => d.message === 'Cette nature est invalide.'))
})

test('documentSchema / date_signature manquante', t => {
  const input = {
    nom_fichier: 'doc.pdf',
    reference: null,
    nature: null,
    date_fin_validite: null,
    date_ajout: '2024-02-01',
    remarque: null
  }
  const error = t.throws(() => validateDocument(input), {instanceOf: ValidationError})
  t.true(error.details.some(d => d.message === 'La date de signature est obligatoire.'))
})

test('documentSchema / date invalides', t => {
  const input = {
    nom_fichier: 'doc.pdf',
    reference: null,
    nature: null,
    date_signature: '2024-13-01',
    date_fin_validite: '2024-02-30',
    date_ajout: '2024-02-01',
    remarque: null
  }
  const error = t.throws(() => validateDocument(input), {instanceOf: ValidationError})
  t.true(error.details.some(d => d.message === 'La date est invalide.'))
})

test('documentSchema / nom_fichier trop court', t => {
  const input = {
    nom_fichier: 'ab',
    reference: null,
    nature: null,
    date_signature: '2024-01-01',
    date_fin_validite: null,
    date_ajout: '2024-02-01',
    remarque: null
  }
  const error = t.throws(() => validateDocument(input), {instanceOf: ValidationError})
  t.true(error.details.some(d => d.message.includes('nom_fichier') && d.message.includes('au moins')))
})

test('documentSchema / reference null acceptable', t => {
  const input = {
    nom_fichier: 'doc-ok.pdf',
    reference: null,
    nature: null,
    date_signature: '2024-01-01',
    date_fin_validite: null,
    date_ajout: '2024-02-01',
    remarque: null
  }
  const value = validateDocument(input)
  t.deepEqual(value, input)
})

test('documentSchema / remarque trop courte', t => {
  const input = {
    nom_fichier: 'doc.pdf',
    reference: 'REF-1',
    nature: null,
    date_signature: '2024-01-01',
    date_fin_validite: null,
    date_ajout: '2024-02-01',
    remarque: 'ab'
  }
  const error = t.throws(() => validateDocument(input), {instanceOf: ValidationError})
  t.true(error.details.some(d => d.message.includes('remarque') && d.message.includes('au moins')))
})

// ---------------- Regle schema tests ----------------

function validateRegle(r) {
  return validatePayload(r, regleSchema)
}

function regleValideBase() {
  return {
    parametre: Object.values(parametres)[0],
    unite: Object.values(unites)[0],
    valeur: 10,
    contrainte: Object.values(contraintes)[0],
    debut_validite: '2024-01-01',
    fin_validite: null,
    debut_periode: null,
    fin_periode: null,
    remarque: null,
    id_regle: null,
    id_document: 'abc123'
  }
}

test('regleSchema / valide', t => {
  const input = regleValideBase()
  const value = validateRegle(input)
  t.deepEqual(value, input)
})

test('regleSchema / parametre invalide', t => {
  const input = {...regleValideBase(), parametre: 'Bidon'}
  const error = t.throws(() => validateRegle(input), {instanceOf: ValidationError})
  t.true(error.details.some(d => d.message === 'Le paramètre est invalide.'))
})

test('regleSchema / unite invalide', t => {
  const input = {...regleValideBase(), unite: 'Bidon'}
  const error = t.throws(() => validateRegle(input), {instanceOf: ValidationError})
  t.true(error.details.some(d => d.message === 'L’unité est invalide.'))
})

test('regleSchema / valeur manquante', t => {
  const input = regleValideBase()
  delete input.valeur
  const error = t.throws(() => validateRegle(input), {instanceOf: ValidationError})
  t.true(error.details.some(d => d.message === 'La valeur est obligatoire.'))
})

test('regleSchema / valeur non numerique', t => {
  const input = {...regleValideBase(), valeur: 'abc'}
  const error = t.throws(() => validateRegle(input), {instanceOf: ValidationError})
  t.true(error.details.some(d => d.message === 'La valeur doit être un nombre.'))
})

test('regleSchema / contrainte invalide', t => {
  const input = {...regleValideBase(), contrainte: 'toto'}
  const error = t.throws(() => validateRegle(input), {instanceOf: ValidationError})
  t.true(error.details.some(d => d.message === 'La contrainte est invalide.'))
})

test('regleSchema / debut_validite manquante', t => {
  const input = regleValideBase()
  delete input.debut_validite
  const error = t.throws(() => validateRegle(input), {instanceOf: ValidationError})
  t.true(error.details.some(d => d.message === 'La date de début de validité est obligatoire.'))
})

test('regleSchema / id_document type invalide', t => {
  const input = {...regleValideBase(), id_document: 123}
  const error = t.throws(() => validateRegle(input), {instanceOf: ValidationError})
  t.true(error.details.some(d => d.message === 'L’id du document doit être une chaine de caractères.'))
})

test('regleSchema / remarque trop courte', t => {
  const input = {...regleValideBase(), remarque: 'ab'}
  const error = t.throws(() => validateRegle(input), {instanceOf: ValidationError})
  t.true(error.details.some(d => d.message.includes('remarque') && d.message.includes('au moins')))
})

// ---------------- Exploitation creation schema tests ----------------

function exploitationValideComplete() {
  return {
    date_debut: '2024-01-01',
    date_fin: null,
    statut: Object.values(statutsExploitation)[0],
    raison_abandon: null,
    remarque: null,
    point: '1234567890abcdef12345678',
    preleveur: 'abcdef1234567890abcdef12',
    usages: [Object.values(usagesNomenclature)[0]],
    regles: [regleValideBase()],
    documents: [{
      nom_fichier: 'autorisation.pdf',
      reference: 'REF-123',
      nature: Object.values(natures)[0],
      date_signature: '2024-01-01',
      date_fin_validite: null,
      date_ajout: '2024-02-01',
      remarque: null
    }]
  }
}

test('exploitationSchemaCreation / valide complet', t => {
  const input = exploitationValideComplete()
  const value = validateCreation(input)
  t.deepEqual(value, input)
})

test('exploitationSchemaCreation / statut manquant', t => {
  const input = exploitationValideComplete()
  delete input.statut
  const error = t.throws(() => validateCreation(input), {instanceOf: ValidationError})
  t.true(error.details.some(d => d.message === 'Le statut est obligatoire.'))
})

test('exploitationSchemaCreation / date_debut manquante', t => {
  const input = exploitationValideComplete()
  delete input.date_debut
  const error = t.throws(() => validateCreation(input), {instanceOf: ValidationError})
  t.true(error.details.some(d => d.message === 'Une date de début est obligatoire.'))
})

test('exploitationSchemaCreation / usages vide', t => {
  const input = exploitationValideComplete()
  input.usages = []
  const error = t.throws(() => validateCreation(input), {instanceOf: ValidationError})
  t.true(error.details.some(d => d.message === 'Au moins un usage est obligatoire.'))
})

test('exploitationSchemaCreation / point id invalide', t => {
  const input = exploitationValideComplete()
  input.point = '123' // Trop court
  const error = t.throws(() => validateCreation(input), {instanceOf: ValidationError})
  t.true(error.details.length > 0)
})

test('exploitationSchemaCreation / regles non tableau', t => {
  const input = exploitationValideComplete()
  // @ts-ignore simulation d’erreur
  input.regles = 'pas un tableau'
  const error = t.throws(() => validateCreation(input), {instanceOf: ValidationError})
  t.true(error.details.some(d => d.message === 'Les règles doivent être dans un tableau.'))
})

test('exploitationSchemaCreation / documents non tableau', t => {
  const input = exploitationValideComplete()
  // @ts-ignore
  input.documents = 'pas un tableau'
  const error = t.throws(() => validateCreation(input), {instanceOf: ValidationError})
  t.true(error.details.some(d => d.message === 'Les documents doivent être dans un tableau.'))
})

test('exploitationSchemaCreation / raison_abandon trop courte', t => {
  const input = exploitationValideComplete()
  input.raison_abandon = 'ab'
  const error = t.throws(() => validateCreation(input), {instanceOf: ValidationError})
  t.true(error.details.some(d => d.message.includes('raison_abandon') && d.message.includes('au moins')))
})

test('exploitationSchemaCreation / raison_abandon trop longue', t => {
  const input = exploitationValideComplete()
  input.raison_abandon = 'a'.repeat(600)
  const error = t.throws(() => validateCreation(input), {instanceOf: ValidationError})
  t.true(error.details.some(d => d.message.includes('raison_abandon') && d.message.includes('plus de')))
})

test('exploitationSchemaCreation / remarque trop courte', t => {
  const input = exploitationValideComplete()
  input.remarque = 'ab'
  const error = t.throws(() => validateCreation(input), {instanceOf: ValidationError})
  t.true(error.details.some(d => d.message.includes('remarque') && d.message.includes('au moins')))
})

// ---------------- Exploitation edition schema tests ----------------

test('exploitationSchemaEdition / valide partiel', t => {
  const changes = {
    remarque: 'Mise à jour',
    usages: [Object.values(usagesNomenclature)[1]]
  }
  const value = validateChanges(changes)
  t.deepEqual(value, changes)
})

test('exploitationSchemaEdition / usage invalide', t => {
  const changes = {usages: ['Bidon']} // Un seul usage invalide
  const error = t.throws(() => validateChanges(changes), {instanceOf: ValidationError})
  t.true(error.details.some(d => d.message === 'Cet usage est invalide.'))
})

test('exploitationSchemaEdition / statut invalide', t => {
  const changes = {statut: 'Bidon'}
  const error = t.throws(() => validateChanges(changes), {instanceOf: ValidationError})
  t.true(error.details.some(d => d.message === 'Ce statut est invalide.'))
})

test('exploitationSchemaEdition / date format invalide', t => {
  const changes = {date_debut: '20240101'}
  const error = t.throws(() => validateChanges(changes), {instanceOf: ValidationError})
  t.true(error.details.some(d => d.message === 'La date est invalide.'))
})

test('exploitationSchemaEdition / point hex invalide', t => {
  const changes = {point: 'zzz'}
  const error = t.throws(() => validateChanges(changes), {instanceOf: ValidationError})
  t.true(error.details.length > 0)
})

test('exploitationSchemaEdition / preleveur hex invalide', t => {
  const changes = {preleveur: '123'}
  const error = t.throws(() => validateChanges(changes), {instanceOf: ValidationError})
  t.true(error.details.length > 0)
})

// Edge cases date dans regle
test('regleSchema / dates invalides multiples', t => {
  const input = regleValideBase()
  input.debut_validite = '2024-13-01'
  input.fin_validite = '2024-00-10'
  const error = t.throws(() => validateRegle(input), {instanceOf: ValidationError})
  t.true(error.details.some(d => d.message === 'La date est invalide.'))
})

// Edge case remarque trop longue
test('documentSchema / remarque trop longue', t => {
  const input = {
    nom_fichier: 'doc.pdf',
    reference: null,
    nature: null,
    date_signature: '2024-01-01',
    date_fin_validite: null,
    date_ajout: '2024-02-01',
    remarque: 'a'.repeat(600)
  }
  const error = t.throws(() => validateDocument(input), {instanceOf: ValidationError})
  t.true(error.details.some(d => d.message.includes('remarque') && d.message.includes('plus de')))
})

// Edition / combinaison champs invalides
test('exploitationSchemaEdition / multiple erreurs', t => {
  const changes = {statut: 'Bidon', usages: ['Bidon'], date_debut: '20240101'}
  const error = t.throws(() => validateChanges(changes), {instanceOf: ValidationError})
  const msgs = new Set(error.details.map(d => d.message))
  t.true(msgs.has('Ce statut est invalide.'))
  t.true(msgs.has('Cet usage est invalide.'))
  t.true(msgs.has('La date est invalide.'))
})
