import Joi from 'joi'
import {validatePayload} from '../util/payload.js'
import {statutsExploitation, usages} from '../nomenclature.js'

function validateDate(date, helpers) {
  if (!date || typeof date !== 'string' || !/^\d{4}-\d{2}-\d{2}$/.test(date)) {
    return helpers.message('La date est invalide.')
  }

  const parsedDate = new Date(date)

  if (parsedDate.toString() === 'Invalid Date') {
    return helpers.message('La date est invalide.')
  }

  return date
}

function validateStatut(statut, helpers) {
  if (!Object.values(statutsExploitation).includes(statut)) {
    return helpers.message('Ce statut est invalide.')
  }

  return statut
}

function validateUsage(usage, helpers) {
  if (!Object.values(usages).includes(usage)) {
    return helpers.message('Cet usage est invalide.')
  }

  return usage
}

function addStringMessages(field, fieldName) {
  return field.messages({
    'string.base': `Le champ "${fieldName}" doit être une chaine de caractères.`,
    'string.empty': `Le champ "${fieldName}" ne peut pas être vide.`,
    'string.min': `Le champ "${fieldName}" doit comporter au moins {#limit} caractères.`,
    'string.max': `Le champ "${fieldName}" ne doit pas comporter plus de {#limit} caractères.`
  })
}

const EXPLOITATION_FIELDS = {
  date_debut: Joi.custom(validateDate),
  date_fin: Joi.custom(validateDate),
  statut: Joi.custom(validateStatut),
  raison_abandon: Joi.string().trim().min(3).max(500),
  remarque: Joi.string().trim().min(3).max(500),
  point: Joi.string().length(24).hex(),
  preleveur: Joi.string().length(24).hex(),
  usages: Joi.array().min(1).items(Joi.string().custom(validateUsage)),
  documents: Joi.array().items(Joi.string().length(24).hex())
}

export const exploitationSchemaCreation = Joi.object().keys({
  date_debut: EXPLOITATION_FIELDS.date_debut.required().messages({
    'any.required': 'Une date de début est obligatoire.'
  }),
  date_fin: EXPLOITATION_FIELDS.date_fin.allow(null),
  statut: EXPLOITATION_FIELDS.statut.required().messages({
    'any.required': 'Le statut est obligatoire.'
  }),
  raison_abandon: addStringMessages(EXPLOITATION_FIELDS.raison_abandon.allow(null), 'raison_abandon'),
  remarque: addStringMessages(EXPLOITATION_FIELDS.remarque.allow(null), 'remarque'),
  point: EXPLOITATION_FIELDS.point.required().messages({
    'any.required': 'L\'id du point est obligatoire.'
  }),
  preleveur: EXPLOITATION_FIELDS.preleveur.required().messages({
    'any.required': 'L\'id du préleveur est obligatoire.'
  }),
  usages: EXPLOITATION_FIELDS.usages.required().messages({
    'array.base': 'Les usages doivent être dans un tableau',
    'string.base': 'Les usages doivent être des chaînes de caractères.',
    'any.required': 'Au moins un usage est obligatoire.',
    'array.min': 'Au moins un usage est obligatoire.'
  }),
  documents: EXPLOITATION_FIELDS.documents.optional().messages({
    'array.base': 'Les documents doivent être dans un tableau.'
  })
})

export const exploitationSchemaEdition = Joi.object().keys({
  date_debut: EXPLOITATION_FIELDS.date_debut,
  date_fin: EXPLOITATION_FIELDS.date_fin.allow(null),
  statut: EXPLOITATION_FIELDS.statut,
  raison_abandon: addStringMessages(EXPLOITATION_FIELDS.raison_abandon.allow(null), 'raison_abandon'),
  remarque: addStringMessages(EXPLOITATION_FIELDS.remarque.allow(null), 'remarque'),
  point: EXPLOITATION_FIELDS.point,
  preleveur: EXPLOITATION_FIELDS.preleveur,
  usages: EXPLOITATION_FIELDS.usages,
  documents: EXPLOITATION_FIELDS.documents
})

export function validateCreation(exploitation) {
  return validatePayload(exploitation, exploitationSchemaCreation)
}

export function validateChanges(changes) {
  return validatePayload(changes, exploitationSchemaEdition)
}
